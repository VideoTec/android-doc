http://www.dewen.io/q/2227/android+

如果一开始就对Android手机的硬件架构有一定的了解，设计出的应用程序通常不会成为待机电池杀手，而要设计出正确的通信机制与通信协议也并不困难。但如果不去了解而盲目设计，可就没准了。

首先Android手机有两个处理器，
一个叫Application Processor（AP），
一个叫Baseband Processor（BP）。

AP是ARM架构的处理器，用于运行Linux+Android系统；
BP用于运行实时操作系统（RTOS），通讯协议栈运行于BP的RTOS之上。

非通话时间，BP的能耗基本上在5mA左右，
而AP只要处于非休眠状态，能耗至少在50mA以上，执行图形运算时会更高。
另外LCD工作时功耗在100mA左右，WIFI也在100mA左右。
一般手机待机时，AP、LCD、WIFI均进入休眠状态，
这时Android中应用程序的代码也会停止执行。

Android为了确保应用程序中关键代码的正确执行，
提供了Wake Lock的API，
使得应用程序有权限通过代码阻止AP进入休眠状态。
但如果不领会Android设计者的意图而滥用Wake Lock API，
为了自身程序在后台的正常工作而长时间阻止AP进入休眠状态，
就会成为待机电池杀手。
比如前段时间的某应用，比如现在仍然干着这事的某应用。

首先，完全没必要担心AP休眠会导致收不到消息推送。
通讯协议栈运行于BP，一旦收到数据包，BP会将AP唤醒，
唤醒的时间足够AP执行代码完成对收到的数据包的处理过程。
其它的如Connectivity事件触发时AP同样会被唤醒。

那么唯一的问题就是程序如何执行向服务器发送心跳包的逻辑。
你显然不能靠AP来做心跳计时。
Android提供的Alarm Manager就是来解决这个问题的。
Alarm应该是BP计时（或其它某个带石英钟的芯片，不太确定，但绝对不是AP），
触发时唤醒AP执行程序代码。

那么Wake Lock API有啥用呢？
比如心跳包从请求到应答，比如断线重连重新登陆这些关键逻辑的执行过程，
就需要Wake Lock来保护。
而一旦一个关键逻辑执行成功，就应该立即释放掉Wake Lock了。
两次心跳请求间隔5到10分钟，基本不会怎么耗电。
除非网络不稳定，频繁断线重连，那种情况办法不多。